# GOST

gost - socks-proxy on Go [https://github.com/ginuerzh/gost/](https://github.com/ginuerzh/gost/)

Сейчас автор пишеет 3-ю версию gost.

## Возможности

* Прослушивание нескольких портов
* Многоуровневый forward proxy — proxy chain
* Поддержка протоколов HTTP/HTTPS/HTTP2/SOCKS4(A)/SOCKS5/...
* Поддержка разного транспорта TCP/TLS/mTLS/WS/WSS/mWS/h2/h2c/SSH/...
* Разные туннели
* ...

rtcp — это reverse tcp mode (или remote — хз)

## Usage

Заметки из документации [https://github.com/ginuerzh/gost/blob/master/README\_en.md](https://github.com/ginuerzh/gost/blob/master/README\_en.md)

### Up Simple Socks Proxy

#### No forward proxy

Поднимаем обычный http/socks5 прокси (любой, кто настроит перенаправление своего траффика, будет ходить через нас):

```
$ gost -L=:8080
```

Добавляем аутентификацию (второй пример — добавление нескольких учеток):

```
$ gost -L=admin:123456@localhost:8080
$ gost -L=localhost:8080?secrets=secrets.txt

$ cat secrets.txt
...
# username password

test001 123456
test002 12345678
```

Прослушивание нескольких портов:

```
$ gost -L=http2://:443 -L=socks5://:1080 -L=ss://aes-128-cfb:123456@:8338
```

#### Forward proxy

Допустим, мы хотим перенаправить на другой прокси трафик, который уже будет смотреть в нужную сеть и/или интернет (второй пример с аутентификацией на прокси)

```
$ gost -L=:8080 -F=192.168.1.1:8081
$ gost -L=:8080 -F=http://admin:123456@192.168.1.1:8081
```

#### Multi-level forward proxy

Сделать запрос через цепочку проксей (считай proxychains). В итоге, запрос пройдет до a.b.c.d:NNNN. Все forward proxy сервера могут быть любого типа из HTTP/HTTPS/HTTP2/SOCKS4/SOCKS5/Shadowsocks.

```
gost -L=:8080 -F=quic://192.168.1.1:6121 -F=socks5+wss://192.168.1.2:1080 -F=http2://192.168.1.3:443 ... -F=a.b.c.d:NNN
```

### Local Port Forwarding

#### Local TCP Port Forwarding

Перенаправить данные с локального порта (2222) на порт на удаленной машине (192.168.1.1:22) через цепочку прокси-серверов:

```
$ gost -L=tcp://:2222/192.168.1.1:22 [-F=...]
```

Если последний узел цепочки (последний параметр -F) является туннелем SSH forward, то gost будет напрямую использовать функцию перенаправления локального порта SSH:

```
$ gost -L=tcp://:2222/192.168.1.1:22 -F forward+ssh://:2222
```

#### Local UDP Port Forwarding

Данные на локальном порту (5353) перенаправляются на порт на удаленной машине (192.168.1.1:53) через цепочку прокси-серверов. У каждого канала пересылки есть период ожидания. Когда это время будет превышено и в течение этого периода не будет взаимодействия с данными, канал будет закрыт. Значение тайм-аута может быть установлено параметром ttl. Значение по умолчанию — 60 секунд.

```
$ gost -L=udp://:5353/192.168.1.1:53?ttl=60 [-F=...]
```

**Замечание**: При пересылке данных UDP, если есть цепочка прокси, концом цепочки (последний параметр -F) должен быть SOCKS5-прокси gost; gost будет использовать UDP-over-TCP для пересылки данных.

### Remote Port Forwarding

#### Remote TCP Port Forwarding

Перенаправить данные с 172.24.10.1:2222 на порт на удаленной машине (192.168.1.1:22) через цепочку прокси-серверов

```
$ gost -L=rtcp://:2222/192.168.1.1:22 [-F=... -F=socks5://172.24.10.1:1080]
```

Если последний узел в цепочке (последний -F параметр) — SSH-тунель, то gost будет использовать remote port forwarding function of SSH напрямую:

```
$ gost -L=rtcp://:2222/192.168.1.1:22 -F forward+ssh://:2222
```

#### Remote UDP Port Forwarding

Данные с 172.24.10.1:5353 перенаправляются на порт на удаленной машине (192.168.1.1:53) через цепочку прокси-серверов. У каждого канала пересылки есть период ожидания. Когда это время будет превышено и в течение этого периода не будет взаимодействия с данными, канал будет закрыт. Значение тайм-аута может быть установлено параметром ttl. Значение по умолчанию — 60 секунд.

```
$ gost -L=rudp://:5353/192.168.1.1:53?ttl=60 [-F=... -F=socks5://172.24.10.1:1080]
```

**Замечание**: При пересылке данных UDP, если есть цепочка прокси, концом цепочки (последний параметр -F) должен быть SOCKS5-прокси gost; gost будет использовать UDP-over-TCP для пересылки данных.

## Примеры

### Проброс в сетку

На нашем серваке (например, **192.168.4.55**). Open local port at **9001** and wait for connect:

```
gost -L socks5://login1:pass1@0.0.0.0:9001
```

Target. Connect to **192.168.4.55:9001**, and all coming from **9002** (that was opened at **192.168.4.55**) send out from **7001**

```
gost -L rtcp://127.0.0.1:9002/127.0.0.1:7001 -F socks5://login1:pass1@192.168.4.55:9001
```

По факту:\
Мы будем ходить на нашем серваке на 9002 порт, а приходить на 7001 на удаленном.

### Проброс SSH

На нашем серваке (например, **192.168.4.55**). Open socks5:

```
gost -L forward+ssh://testlog:testpass@0.0.0.0:2222
```

Target. Connect to **192.168.4.55** and forward all from **127.0.0.1:1222** to **localhost:22**

```
gost -L rtcp://127.0.0.1:1222/:22 -F forward+ssh://testlog:testpass@192.168.4.55:2222
```

По факту:\
Мы будем обращаться на нашем серваке на 1222 порт, а ходить на удаленном на 22.
