# C3 (Custom Command and Control) framework (MWR Labs) (C++)

link: [https://github.com/mwrlabs/C3](https://github.com/mwrlabs/C3)

Наконец, последний фреймворк для постэксплуатации, который мы рассмотрим. Он представляет собой своего рода обертку над C2. Суть фреймворков C3 — в гибкой коммуникации внешнего C2 через легитимные процессы. Например, можно в этих целях приспособить Office 365, Slack, Google Drive, Dropbox и другие сервисы, которые повседневно используются в офисах.

Впервые концепция С3 была представлена на конференции BlueHat v18 Уильямом Ноулзом и Дэйвом Хартли. Фреймворк MWR Labs имеет открытый исходный код и состоит из следующих узлов.

* **Релей** — исполняемый файл, запущенный на скомпрометированной системе. Релеи взаимодействуют между собой через интерфейсы либо напрямую со шлюзом.
* **Шлюз** — специальный релей для управления одной сетью C3, отвечает за обратную связь с C2.
* **Канал** — схема взаимодействия релея внутри легитимных процессов, типичных для атакуемой системы, например через API Slack.
* **Обратный шлюзовой канал** (Gateway Return Channel) — сконфигурированный канал, который используется релеем для отправки данных обратно на шлюз. Также может быть маршрутом через другой релей.
* **Интерфейс** — высокоуровневое имя, присваиваемое любому устройству, облегчающему отправку и получение данных в сети C3.
* **Маршрут** — предполагаемый путь коммуникаций через релей обратно к шлюзу. В качестве периферийного устройства выступает сторонний имплант C2 (например, Cobalt Strike SMB beacon).
* **Коннектор** — интеграция со сторонними системами C2. Кстати, C3 в исполнении MWR Labs поддерживает тесную интеграцию с TeamServer Cobalt Strike. В качестве коннектора хорошо работает инстанс Cobalt Strike под названием External C2 (команда `externalc2_start` через менеджер скриптов).

На первый взгляд кажется, что C3 слишком сложный, — нужно время, чтобы во всем этом разобраться. Но на деле помогают удобный интерфейс, скоростной деплой и возможность самостоятельно определять архитектуру с учетом специфики атакуемой системы и прочих вещей.

Первым делом запусти WebController и задай URL. Либо можешь выполнить скрипт StartWebController.cmd.

![](<../../.gitbook/assets/изображение (2).png>)

Дальше в веб-приложении необходимо сконфигурировать первый шлюз. Как ты уже знаешь, без него работать ничего не будет.&#x20;

![](<../../.gitbook/assets/изображение (3) (1).png>)

После того как шлюз выйдет на связь, ты автоматически попадешь в консоль управления фреймворком, где уже будешь строить свою архитектуру.

![](<../../.gitbook/assets/изображение (4).png>)

Многие действия выполняются всего в пару кликов. Ты с легкостью можешь сгенерировать новый канал, кликнув на шлюз, аналогично на созданный канал — для генерации нового релея. Вся необходимая информация здесь будет автоматически заполнена. На данном этапе можно указать архитектуру, тип файла (.exe, .dll) и прочее.

По каждому релею доступна подробная информация: версия ОС, под каким пользователем запущен и когда последний раз был онлайн.

![](<../../.gitbook/assets/изображение (5) (1).png>)

Еще важно знать, что тут существует два типа каналов. Согласованный канал позволяет иметь несколько связей между шлюзом и релеями (по одному каналу), несогласованный обеспечивает возможность связи только одного релея со шлюзом. На скрине представлен пример организации согласованного канала через API Slack.

![](<../../.gitbook/assets/изображение (6).png>)

Фреймворк можно тонко настраивать и делать любые схемы коммуникации. Ты можешь реализовать любые творческие сценарии, что ценно само по себе.
